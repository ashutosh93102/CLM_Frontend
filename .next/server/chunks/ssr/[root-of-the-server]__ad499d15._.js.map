{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../app/lib/env.ts","../../../../app/lib/api.ts","../../../../app/lib/auth-context.tsx"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","/**\n * Centralized environment-derived configuration.\n *\n * Cloudflare Pages / Next.js will inline NEXT_PUBLIC_* variables at build time.\n */\n\nconst DEFAULT_API_BASE_URL = 'https://lawflow-267708864896.asia-south1.run.app'\n\nfunction normalizeBaseUrl(raw: string): string {\n  return raw.trim().replace(/\\/+$/, '')\n}\n\n/**\n * Canonical backend base URL.\n *\n * Supported env vars (in priority order):\n * - NEXT_PUBLIC_API_BASE_URL (preferred)\n * - NEXT_PUBLIC_API_URL (legacy)\n */\nexport const API_BASE_URL: string = normalizeBaseUrl(\n  process.env.NEXT_PUBLIC_API_BASE_URL ||\n    process.env.NEXT_PUBLIC_API_URL ||\n    DEFAULT_API_BASE_URL\n)\n","/**\n * CLM Backend API Client\n * Production-level API integration with proper error handling and typing\n */\n\nimport { API_BASE_URL } from './env'\n\nconst BASE_URL = API_BASE_URL\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\nexport interface User {\n  user_id: string\n  email: string\n  full_name?: string\n  tenant_id?: string\n  is_admin?: boolean\n  is_superadmin?: boolean\n}\n\nexport interface AuthResponse {\n  access: string\n  refresh: string\n  user: User\n  message?: string\n}\n\nexport interface OTPResponse {\n  message: string\n}\n\nexport interface PendingRegisterResponse {\n  message: string\n  pending_verification: true\n  email: string\n}\n\nexport interface ErrorResponse {\n  error?: string\n  message?: string\n  detail?: string\n}\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface RegisterCredentials {\n  email: string\n  password: string\n  full_name: string\n}\n\nexport interface ResetPasswordData {\n  email: string\n  otp: string\n  password: string\n}\n\nexport interface VerifyOTPData {\n  email: string\n  otp: string\n}\n\n// ============================================================================\n// API ERROR HANDLING\n// ============================================================================\n\nexport class APIError extends Error {\n  constructor(\n    public status: number,\n    public message: string,\n    public data?: any\n  ) {\n    super(message)\n    this.name = 'APIError'\n  }\n}\n\nfunction formatValidationErrors(data: any): string | null {\n  if (!data || typeof data !== 'object' || Array.isArray(data)) return null\n\n  const parts: string[] = []\n  for (const [rawKey, value] of Object.entries(data)) {\n    if (value == null) continue\n\n    const key = String(rawKey)\n    const label = key.replace(/_/g, ' ')\n\n    const collect = (v: any): string[] => {\n      if (v == null) return []\n      if (typeof v === 'string') return [v]\n      if (Array.isArray(v)) return v.flatMap(collect)\n      if (typeof v === 'object') {\n        if (typeof (v as any).detail === 'string') return [(v as any).detail]\n        if (typeof (v as any).message === 'string') return [(v as any).message]\n        const nested = formatValidationErrors(v)\n        if (nested) return [nested]\n        try {\n          return [JSON.stringify(v)]\n        } catch {\n          return [String(v)]\n        }\n      }\n      return [String(v)]\n    }\n\n    const messages = collect(value).filter(Boolean)\n    if (messages.length === 0) continue\n\n    // Prefer showing general errors without a noisy label.\n    if (key === 'non_field_errors' || key === 'detail') {\n      parts.push(messages.join(' '))\n      continue\n    }\n\n    parts.push(`${label}: ${messages.join(' ')}`)\n  }\n\n  return parts.length ? parts.join(' â€¢ ') : null\n}\n\nasync function handleResponse<T>(response: Response): Promise<T> {\n  const contentType = response.headers.get('content-type')\n  let data: any\n\n  try {\n    if (contentType?.includes('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n  } catch (error) {\n    data = null\n  }\n\n  if (!response.ok) {\n    let errorMessage =\n      data?.error ||\n      data?.message ||\n      data?.detail ||\n      (typeof data === 'string' ? data : null) ||\n      formatValidationErrors(data) ||\n      `HTTP Error: ${response.status}`\n\n    throw new APIError(response.status, errorMessage, data)\n  }\n\n  return data as T\n}\n\n// ============================================================================\n// TOKEN MANAGEMENT\n// ============================================================================\n\nexport const tokenManager = {\n  _notifyAuthChanged: (): void => {\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(new Event('auth:tokens'))\n    }\n  },\n\n  getAccessToken: (): string | null => {\n    if (typeof window !== 'undefined') {\n      return localStorage.getItem('access_token')\n    }\n    return null\n  },\n\n  getRefreshToken: (): string | null => {\n    if (typeof window !== 'undefined') {\n      return localStorage.getItem('refresh_token')\n    }\n    return null\n  },\n\n  setTokens: (access: string, refresh: string): void => {\n    if (typeof window !== 'undefined') {\n      localStorage.setItem('access_token', access)\n      localStorage.setItem('refresh_token', refresh)\n      tokenManager._notifyAuthChanged()\n    }\n  },\n\n  setUser: (user: User): void => {\n    if (typeof window !== 'undefined') {\n      localStorage.setItem('user', JSON.stringify(user))\n      tokenManager._notifyAuthChanged()\n    }\n  },\n\n  getUser: (): User | null => {\n    if (typeof window !== 'undefined') {\n      const user = localStorage.getItem('user')\n      return user ? JSON.parse(user) : null\n    }\n    return null\n  },\n\n  clearTokens: (): void => {\n    if (typeof window !== 'undefined') {\n      localStorage.removeItem('access_token')\n      localStorage.removeItem('refresh_token')\n      localStorage.removeItem('user')\n      tokenManager._notifyAuthChanged()\n    }\n  },\n\n  /**\n   * Decode JWT token payload\n   */\n  decodeToken: (token: string): any => {\n    try {\n      const parts = token.split('.')\n      if (parts.length !== 3) {\n        throw new Error('Invalid token format')\n      }\n\n      const decoded = JSON.parse(\n        Buffer.from(parts[1], 'base64').toString('utf-8')\n      )\n      return decoded\n    } catch (error) {\n      console.error('Failed to decode token:', error)\n      return null\n    }\n  },\n\n  /**\n   * Check if token is expired\n   */\n  isTokenExpired: (token: string): boolean => {\n    const decoded = tokenManager.decodeToken(token)\n    if (!decoded || !decoded.exp) {\n      return true\n    }\n\n    const expirationTime = decoded.exp * 1000\n    return Date.now() >= expirationTime\n  },\n\n  /**\n   * Get time until token expiration in milliseconds\n   */\n  getTokenExpirationTime: (token: string): number => {\n    const decoded = tokenManager.decodeToken(token)\n    if (!decoded || !decoded.exp) {\n      return 0\n    }\n\n    return decoded.exp * 1000 - Date.now()\n  },\n}\n\n// ============================================================================\n// API CLIENT METHODS\n// ============================================================================\n\n/**\n * Register a new user\n * POST /api/auth/register/\n */\nexport async function registerUser(\n  credentials: RegisterCredentials\n): Promise<PendingRegisterResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/register/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(credentials),\n  })\n\n  return handleResponse<PendingRegisterResponse>(response)\n}\n\n/**\n * Login user with email and password\n * POST /api/auth/login/\n */\nexport async function loginUser(\n  credentials: LoginCredentials\n): Promise<AuthResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/login/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(credentials),\n  })\n\n  return handleResponse<AuthResponse>(response)\n}\n\n/**\n * Login/register via Google ID token (credential)\n * POST /api/auth/google/\n */\nexport async function googleLogin(credential: string): Promise<AuthResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/google/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ credential }),\n  })\n\n  const result = await handleResponse<AuthResponse>(response)\n  tokenManager.setTokens(result.access, result.refresh)\n  tokenManager.setUser(result.user)\n  return result\n}\n\n/**\n * Get current authenticated user\n * GET /api/auth/me/\n */\nexport async function getCurrentUser(accessToken: string): Promise<User> {\n  const response = await fetch(`${BASE_URL}/api/auth/me/`, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  })\n\n  return handleResponse<User>(response)\n}\n\n/**\n * Refresh access token using refresh token\n * POST /api/auth/refresh/\n */\nexport async function refreshAccessToken(\n  refreshToken: string\n): Promise<AuthResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/refresh/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ refresh: refreshToken }),\n  })\n\n  return handleResponse<AuthResponse>(response)\n}\n\n/**\n * Logout user\n * POST /api/auth/logout/\n */\nexport async function logoutUser(accessToken: string): Promise<OTPResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/logout/`, {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n  })\n\n  return handleResponse<OTPResponse>(response)\n}\n\n/**\n * Request OTP for passwordless login\n * POST /api/auth/request-login-otp/\n */\nexport async function requestLoginOTP(email: string): Promise<OTPResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/request-login-otp/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ email }),\n  })\n\n  return handleResponse<OTPResponse>(response)\n}\n\n/**\n * Verify email OTP (for registration/verification)\n * POST /api/auth/verify-email-otp/\n */\nexport async function verifyEmailOTP(\n  data: VerifyOTPData\n): Promise<AuthResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/verify-email-otp/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  const result = await handleResponse<AuthResponse>(response)\n  tokenManager.setTokens(result.access, result.refresh)\n  tokenManager.setUser(result.user)\n  return result\n}\n\n/**\n * Request password reset OTP\n * POST /api/auth/forgot-password/\n */\nexport async function requestPasswordReset(email: string): Promise<OTPResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/forgot-password/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ email }),\n  })\n\n  return handleResponse<OTPResponse>(response)\n}\n\n/**\n * Verify password reset OTP\n * POST /api/auth/verify-password-reset-otp/\n */\nexport async function verifyPasswordResetOTP(\n  data: VerifyOTPData\n): Promise<OTPResponse> {\n  const response = await fetch(\n    `${BASE_URL}/api/auth/verify-password-reset-otp/`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    }\n  )\n\n  return handleResponse<OTPResponse>(response)\n}\n\n/**\n * Resend password reset OTP\n * POST /api/auth/resend-password-reset-otp/\n */\nexport async function resendPasswordResetOTP(\n  email: string\n): Promise<OTPResponse> {\n  const response = await fetch(\n    `${BASE_URL}/api/auth/resend-password-reset-otp/`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ email }),\n    }\n  )\n\n  return handleResponse<OTPResponse>(response)\n}\n\n/**\n * Reset password with OTP\n * POST /api/auth/reset-password/\n */\nexport async function resetPassword(\n  data: ResetPasswordData\n): Promise<OTPResponse> {\n  const response = await fetch(`${BASE_URL}/api/auth/reset-password/`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  return handleResponse<OTPResponse>(response)\n}\n\n// ============================================================================\n// CONTRACT MANAGEMENT APIS\n// ============================================================================\n\nexport interface Contract {\n  id: string\n  title: string\n  description?: string\n  status: 'draft' | 'in-review' | 'approved' | 'signed'\n  created_at: string\n  updated_at: string\n  value?: number\n  counter_party?: string\n}\n\nexport interface ContractVersion {\n  id: string\n  contract_id: string\n  version_number: number\n  content: string\n  created_at: string\n}\n\nexport const contractAPI = {\n  // GET /api/contracts/statistics/\n  getStatistics: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/statistics/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/contracts/recent/\n  getRecentContracts: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/recent/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/contracts/\n  listContracts: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<Contract[]>(response)\n  },\n\n  // POST /api/contracts/\n  createContract: async (accessToken: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<Contract>(response)\n  },\n\n  // GET /api/contracts/{id}/\n  getContractById: async (accessToken: string, id: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/${id}/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<Contract>(response)\n  },\n\n  // PUT /api/contracts/{id}/\n  updateContract: async (accessToken: string, id: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/${id}/`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<Contract>(response)\n  },\n\n  // POST /api/contracts/{id}/clone/\n  cloneContract: async (accessToken: string, id: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/${id}/clone/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<Contract>(response)\n  },\n\n  // POST /api/contracts/{id}/versions/\n  createContractVersion: async (accessToken: string, id: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/${id}/versions/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<ContractVersion>(response)\n  },\n\n  // GET /api/contracts/{id}/versions/\n  listContractVersions: async (accessToken: string, id: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/${id}/versions/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<ContractVersion[]>(response)\n  },\n\n  // POST /api/contracts/validate-clauses/\n  validateClauses: async (accessToken: string, clauses: unknown[]) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/validate-clauses/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({ clauses }),\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/contracts/search/\n  searchContracts: async (accessToken: string, query: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/search/?q=${encodeURIComponent(query)}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<Contract[]>(response)\n  },\n\n  // GET /api/contracts/filter/\n  filterContracts: async (accessToken: string, status: string) => {\n    const response = await fetch(`${BASE_URL}/api/contracts/filter/?status=${status}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<Contract[]>(response)\n  },\n}\n\n// ============================================================================\n// TEMPLATE TYPES\n// ============================================================================\n\nexport interface TemplateField {\n  name: string\n  type: string\n  description: string\n}\n\nexport interface TemplateTypeInfo {\n  display_name: string\n  description: string\n  contract_type: string\n  required_fields: TemplateField[]\n  optional_fields: TemplateField[]\n  mandatory_clauses: string[]\n  business_rules?: Record<string, any>\n  sample_data?: Record<string, any>\n}\n\nexport interface TemplateTypesResponse {\n  success: boolean\n  total_types: number\n  template_types: Record<string, TemplateTypeInfo>\n}\n\nexport interface TemplateTypeDetailResponse {\n  success: boolean\n  template_type: string\n  display_name: string\n  description: string\n  contract_type: string\n  required_fields: TemplateField[]\n  optional_fields: TemplateField[]\n  mandatory_clauses: string[]\n  business_rules?: Record<string, any>\n  sample_data?: Record<string, any>\n}\n\nexport interface TemplateValidateRequest {\n  template_type: string\n  data: Record<string, any>\n}\n\nexport interface TemplateValidateResponse {\n  success: boolean\n  is_valid: boolean\n  missing_fields: string[]\n  message: string\n}\n\nexport interface TemplateCreateRequest {\n  template_type: string\n  name: string\n  description?: string\n  status: 'draft' | 'published'\n  data: Record<string, any>\n}\n\nexport interface TemplateCreateResponse {\n  success: boolean\n  template_id: string\n  name: string\n  contract_type: string\n  status: string\n  merge_fields: string[]\n  mandatory_clauses: string[]\n  message: string\n}\n\nexport const templateAPI = {\n  // GET /api/v1/templates/types/ - Get all template types\n  getAllTemplateTypes: async (accessToken: string): Promise<TemplateTypesResponse> => {\n    const response = await fetch(`${BASE_URL}/api/v1/templates/types/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<TemplateTypesResponse>(response)\n  },\n\n  // GET /api/v1/templates/types/{type}/ - Get specific template type details\n  getTemplateTypeDetail: async (\n    accessToken: string,\n    templateType: string\n  ): Promise<TemplateTypeDetailResponse> => {\n    const response = await fetch(`${BASE_URL}/api/v1/templates/types/${templateType}/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<TemplateTypeDetailResponse>(response)\n  },\n\n  // GET /api/v1/templates/summary/ - Get template summary\n  getTemplateSummary: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/v1/templates/summary/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // POST /api/v1/templates/validate/ - Validate template data\n  validateTemplateData: async (\n    accessToken: string,\n    data: TemplateValidateRequest\n  ): Promise<TemplateValidateResponse> => {\n    const response = await fetch(`${BASE_URL}/api/v1/templates/validate/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<TemplateValidateResponse>(response)\n  },\n\n  // POST /api/v1/templates/create-from-type/ - Create template from type\n  createTemplateFromType: async (\n    accessToken: string,\n    data: TemplateCreateRequest\n  ): Promise<TemplateCreateResponse> => {\n    const response = await fetch(`${BASE_URL}/api/v1/templates/create-from-type/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<TemplateCreateResponse>(response)\n  },\n\n  // Legacy endpoints (kept for backward compatibility)\n  // GET /api/v1/contract-templates/\n  getTemplates: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/v1/contract-templates/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n\n  // POST /api/v1/contract-templates/\n  createTemplate: async (accessToken: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/v1/contract-templates/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/v1/contract-templates/{id}/\n  getTemplateById: async (accessToken: string, id: string) => {\n    const response = await fetch(`${BASE_URL}/api/v1/contract-templates/${id}/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n}\n\nexport const workflowAPI = {\n  // GET /api/workflows/\n  getWorkflows: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/workflows/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n\n  // POST /api/workflows/\n  createWorkflow: async (accessToken: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/workflows/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/workflows/{id}/\n  getWorkflowById: async (accessToken: string, id: string) => {\n    const response = await fetch(`${BASE_URL}/api/workflows/${id}/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n}\n\nexport const notificationAPI = {\n  // GET /api/notifications/\n  getNotifications: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/notifications/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n\n  // POST /api/notifications/\n  createNotification: async (accessToken: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/notifications/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<any>(response)\n  },\n}\n\nexport const approvalAPI = {\n  // POST /api/approval-requests/\n  createApprovalRequest: async (accessToken: string, data: any) => {\n    const response = await fetch(`${BASE_URL}/api/approval-requests/`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(data),\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/approval-requests/pending/\n  getPendingApprovals: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/approval-requests/pending/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n}\n\nexport const repositoryAPI = {\n  // GET /api/documents/\n  getDocuments: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/documents/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n\n  // GET /api/repository/\n  getRepositoryContents: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/repository/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any>(response)\n  },\n\n  // GET /api/repository/folders/\n  getRepositoryFolders: async (accessToken: string) => {\n    const response = await fetch(`${BASE_URL}/api/repository/folders/`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n\n    return handleResponse<any[]>(response)\n  },\n}\n\n// ============================================================================\n// COMPATIBILITY AUTH API (used by legacy components like AuthPage)\n// ============================================================================\n\nexport const authAPI = {\n  register: async (data: {\n    email: string\n    password: string\n    first_name?: string\n    last_name?: string\n    company?: string\n  }) => {\n    const full_name = [data.first_name, data.last_name]\n      .filter(Boolean)\n      .join(' ')\n      .trim() || data.first_name || data.last_name || data.email\n\n    const result = await registerUser({\n      email: data.email,\n      password: data.password,\n      full_name,\n      // Extra field supported by backend (best-effort).\n      ...(data.company ? ({ company: data.company } as any) : {}),\n    })\n    return result\n  },\n\n  login: async (data: { email: string; password: string }) => {\n    const result = await loginUser(data)\n    tokenManager.setTokens(result.access, result.refresh)\n    tokenManager.setUser(result.user)\n    return result\n  },\n\n  googleLogin: async (credential: string) => {\n    return googleLogin(credential)\n  },\n\n  forgotPassword: async (email: string) => {\n    return requestPasswordReset(email)\n  },\n\n  resetPassword: async (data: ResetPasswordData) => {\n    return resetPassword(data)\n  },\n\n  logout: () => {\n    tokenManager.clearTokens()\n  },\n}\n","'use client'\n\nimport React, { createContext, useContext, useState, useEffect } from 'react'\nimport { authAPI, tokenManager, User } from './api'\nimport { ApiClient } from './api-client'\n\ninterface AuthContextType {\n  isAuthenticated: boolean\n  isLoading: boolean\n  error: string | null\n  user: User | null\n  login: (email: string, password: string) => Promise<void>\n  loginWithGoogle: (credential: string) => Promise<void>\n  register: (data: { email: string; password: string; full_name: string; company?: string }) => Promise<void>\n  logout: () => void\n  clearError: () => void\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [isAuthenticated, setIsAuthenticated] = useState(false)\n  const [isLoading, setIsLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n  const [user, setUser] = useState<User | null>(null)\n\n  useEffect(() => {\n    const bootstrap = async () => {\n      const token = tokenManager.getAccessToken()\n      const cachedUser = tokenManager.getUser()\n\n      setIsAuthenticated(!!token)\n      setUser(cachedUser)\n\n      // If we have a token but no cached user (e.g. older login flow), fetch /me once.\n      if (token && !cachedUser) {\n        try {\n          const client = new ApiClient()\n          const me = await client.getCurrentUser()\n          if (me.success && me.data) {\n            const u = (me.data as any) as User\n            setUser(u)\n            tokenManager.setUser(u)\n          }\n        } catch {\n          // ignore\n        }\n      }\n\n      setIsLoading(false)\n    }\n\n    bootstrap()\n\n    const syncFromStorage = () => {\n      const token = tokenManager.getAccessToken()\n      const cachedUser = tokenManager.getUser()\n      setIsAuthenticated(!!token)\n      setUser(cachedUser)\n      // Don't touch isLoading here; this is a reactive sync.\n    }\n\n    const handleLogout = () => {\n      tokenManager.clearTokens()\n      setIsAuthenticated(false)\n      setUser(null)\n      setError(null)\n    }\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('auth:logout', handleLogout)\n      window.addEventListener('auth:tokens', syncFromStorage)\n      window.addEventListener('storage', (e) => {\n        if (e.key === 'access_token' && !e.newValue) {\n          handleLogout()\n        }\n      })\n    }\n\n    return () => {\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('auth:logout', handleLogout)\n        window.removeEventListener('auth:tokens', syncFromStorage)\n      }\n    }\n  }, [])\n\n  const login = async (email: string, password: string) => {\n    try {\n      setError(null)\n      const response = await authAPI.login({ email, password })\n      setUser(response.user)\n      setIsAuthenticated(true)\n    } catch (err: any) {\n      const errorMessage = err?.message || err?.detail || 'Login failed'\n      setError(errorMessage)\n      throw err\n    }\n  }\n\n  const loginWithGoogle = async (credential: string) => {\n    try {\n      setError(null)\n      const response = await authAPI.googleLogin(credential)\n      setUser(response.user)\n      setIsAuthenticated(true)\n    } catch (err: any) {\n      const errorMessage = err?.message || err?.detail || 'Google login failed'\n      setError(errorMessage)\n      throw err\n    }\n  }\n\n  const register = async (data: { email: string; password: string; full_name: string; company?: string }) => {\n    try {\n      setError(null)\n      await authAPI.register({\n        email: data.email,\n        password: data.password,\n        first_name: data.full_name,\n        company: data.company,\n      })\n      // Registration now requires OTP verification before login.\n      setUser(null)\n      setIsAuthenticated(false)\n    } catch (err: any) {\n      const errorMessage = err?.message || err?.detail || 'Registration failed'\n      setError(errorMessage)\n      throw err\n    }\n  }\n\n  const logout = () => {\n    tokenManager.clearTokens()\n    setIsAuthenticated(false)\n    setUser(null)\n    setError(null)\n  }\n\n  const clearError = () => {\n    setError(null)\n  }\n\n  return (\n    <AuthContext.Provider value={{ isAuthenticated, isLoading, error, user, login, loginWithGoogle, register, logout, clearError }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"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","ignoreList":[0,1,2]}